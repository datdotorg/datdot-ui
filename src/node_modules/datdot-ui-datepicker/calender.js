const global = {}
document.body.style = `display: flex; background-color: pink;`
const parser = document.createElement('div')
// ----------------------------------------------------------------
// demo.js
// ----------------------------------------------------------------
// USE COMPONENT:
// const makelog = require('make-log')
// const calendar = require('calendar')
// const cals = require('connected-calendar')
const name = 'demo.js'
const log = makelog(name)
log({ from: name, type: 'ready' })

document.body.append(calendar({ days: 30 }, protocol))
document.body.append(cals({ days1: 28, days2: 31 }, protocol))

function protocol (send) {
  return (message) => {
     const { type, body } = message
     if (type === 'value') log(message)
  }
}
// ----------------------------------------------------------------
// connected-calendar.js
// ----------------------------------------------------------------
// DEFINE COMPONENT:
// const calendar = require('calendar')
// module.exports = cals
function cals ({ name = 'concal', month, days1, days2, status = 'cleared' }, protocol) {
  const log = makelog(name)
  log({ from: name, type: 'ready' })
  const sendParent = protocol(function receive (message) { log(message) })

  const recipients = {}
  var value = {}

  const cal1name = 'cal1'
  const cal2name = 'cal2'
  const cal1 = calendar({ name: cal1name, days: days1, status }, calendar_protocol)
  const cal2 = calendar({ name: cal2name, days: days2, status }, calendar_protocol)
  
  const element = document.createElement('div')
  element.append(cal1)
  element.append(cal2)
  // element.onmouseleave = onmouseleave

  return element
  /******************************************************
    STATE
            RULES:
            1. a component must always do the same thing in the same status
            2. only a component can update it's own status
              * another component can only send a message
              * the receiving component might update it's own status in response
  ******************************************************/
  function setStatus (nextStatus) {
  if (name === 'concal') console.log({send2: `${send}` })
    log({ from: status, type: 'status', body: nextStatus })
    status = nextStatus
  }
  /******************************************************
    COMMUNICATION
  ******************************************************/
  function calendar_protocol (send) {
    return message => {
      const { from, type, body } = message
      if (type === 'init') return storeSendFN(from, send)
      if (type === 'value/first') return notifyAndStoreFirst(from, body)
      if (type === 'value/last') return notifyParent(body)
      if (type === 'selecting-second') return notifyOtherCalenderSelectingLast(from)
      if (type === 'cleared') return clearOther(from === cal1name ? cal2name : cal1name)
      else return forwardMessage(from, message)
    }
  }
  /******************************************************
    EVENT LISTENERS
  ******************************************************/
  // function onmouseleave (event) { }
  /******************************************************
    HELPER FUNCTIONS
  ******************************************************/
  function clearOther (from) {
    const send = recipients[from]
    return send({ from: name, type: 'clear' }) // send command
  }
  function notifyOtherCalenderSelectingLast (from) {
    if (from === cal1name) {
      const send = recipients[cal2name]
      return send({ from: name, type: 'color-from-start' })
    }
    if (from === cal2name) {
      const send = recipients[cal1name]
      return send({ from: name, type: 'color-to-end' })
    }
  }
  function storeSendFN (from, send) {
    recipients[from] = send
  }
  function notifyAndStoreFirst (from, body) {
    value.first = body
    const list = [from]
    const receivers = filterOutRecipients(list)
    const type = from === cal1name ? 'first-selected-by-startcal' : 'first-selected-by-endcal'
    return broadcast(receivers, { from: name, type })
  }
  function forwardMessage(from, message) {
    const list = [from]
    const receivers = filterOutRecipients(list)
    broadcast(receivers, message)
  }
  function notifyParent (body) {
    value.last = body
    return sendParent({ from: name, type: 'value', body: value })
  }
  function filterOutRecipients (list) {
    // e.g. args = ['bob', 'eve', 'ana']
    // e.g. recipients = { bob: send1, joe: send2, eve: send3, ana: send4 }
    // ['bob', 'joe', 'eve', 'ana']
    const receivers = Object.keys(recipients) // get all calendar names
      .filter(name => !list.includes(name)) // only keep name different from message sender
      // e.g. receivers = ['joe', 'ana']
      .map(name => recipients[name]) // for each name, get send function
    return receivers // e.g. receivers = [send2, send4]
  }
  function broadcast (receivers, message) {
    for (var i = 0, len = receivers.length; i < len; i++) {
      const send = receivers[i]
      send(message) // forward message from sender to all receivers send(msg)
    }
  }
}


// ----------------------------------------------------------------
// calendar.js
// ----------------------------------------------------------------
// DEFINE SUB COMPONENT
// module.exports = calendar
function calendar ({ name = 'cal', days, status = 'cleared' }, protocol) {
  const log = makelog(name)
  const send = protocol(receive)
  send({ from: name, type: 'init' })

  var first, second
 
  const cal = makeElement(days)
  const buttons = [...cal.children]
  cal.onmousemove  = onmousemove
  cal.onclick      = onclick
  cal.onmouseleave = onmouseleave
  cal.onmouseenter = onmouseenter

  return cal
  /******************************************************
    STATE
            RULES:
            1. a component must always do the same thing in the same status
            2. only a component can update it's own status
              * another component can only send a message
              * the receiving component might update it's own status in response
  ******************************************************/
  function setStatus (nextStatus) {
    log({ from: status, type: 'status', body: nextStatus })
    status = nextStatus
  }
  /******************************************************
    COMMUNICATION
  ******************************************************/
  function receive (message) {
    const { type, body } = message
    log(message)
    if (type === 'clear') return actionClear(body)
    if (type === 'selecting-second') return actionSelectingSecond(body)
    if (type === 'not-selecting-second') return actionKeepFirst(body)
    if (type === 'first-selected-by-endcal') return setStatus('first-selected-by-endcal')
    if (type === 'first-selected-by-startcal') return setStatus('first-selected-by-startcal')
    if (type === 'second-selected') return setStatus('second-selected-by-other')
    if (type === 'color-from-start') return actionColorFromStart()
    if (type === 'color-to-end') return actionColorToEnd()
  }
  /******************************************************
    MESSAGE HANDLERS (from system):
    
      an 'action' might always do the same thing
      but maybe it does a different thing
      depending on the current STATUS, e.g.:
      
      function actionNAME () {
        // ... actions here applies in any status ...
        if (status === 'cleared') return // ... action here only applies in status: 'cleared'
        if (status === 'first-selected-by-self') return // ... same ...
        if (status === 'first-selected-other') return
        if (status === 'second-selected-by-self') return
        if (status === 'second-selected-by-other') return
      }
  ******************************************************/
  function actionColorFromStart () { colorRange(0, first) }
  function actionColorToEnd () { colorRange(first, days + 1) }
  function actionKeepFirst (body) { onlykeepfirst() }
  function actionSelectingSecond (body) { colorRange(0, first) }
  function actionClear (body) { clearSelf() }
  /******************************************************
    EVENT LISTENERS (from user):
  ******************************************************/
  function onmouseenter (event) {
    // ACTIONS (based on current STATE)
    if (status === 'cleared') return
    if (status === 'first-selected-by-self') return
    if (status === 'first-selected-by-startcal') return notifyOther()
    if (status === 'first-selected-by-endcal') return notifyOther()
    if (status === 'second-selected-by-self') return
    if (status === 'second-selected-by-other') return
  }
  function onmousemove (event) {
    const btn = event.target
    const current = parseInt(btn.getAttribute('num'))
    if (!current) return // if not a button, return
    // ACTIONS (based on current STATE)
    if (status === 'cleared') return
    if (status === 'first-selected-by-self') return markRange(btn, first, current)
    if (status === 'first-selected-by-startcal')return markRange(btn, 0, current)
    if (status === 'first-selected-by-endcal')return markRange(btn, first, current)
    if (status === 'second-selected-by-self') return
    if (status === 'second-selected-by-other') return
  }
  function onclick (event) {
    const btn = event.target
    const current = parseInt(btn.getAttribute('num'))
    if (!current) return // if not a button, return
    // ACTIONS (based on current STATE)
    if (status === 'cleared') return selectFirst(btn, current)
    if (status === 'first-selected-by-self') return selectSecond(btn, current)
    if (status === 'first-selected-by-startcal') return selectSecond(btn, current)
    if (status === 'first-selected-by-endcal') return selectSecond(btn, current)
    if (status === 'second-selected-by-self') return selectFirst(btn, current)
    if (status === 'second-selected-by-other') return selectFirst(btn, current)
  }
  function onmouseleave (event) {
    // ACTIONS (based on current STATE)
    if (status === 'cleared') return
    if (status === 'first-selected-by-self') return onlykeepfirst()
    if (status === 'first-selected-by-startcal') return clearAndNotify()
    if (status === 'first-selected-by-endcal') return clearAndNotify()
    if (status === 'second-selected-by-self') return
    if (status === 'second-selected-by-other') return
  }
  /******************************************************
    HELPER FUNCTIONS
  ******************************************************/
  function onlykeepfirst () {
    for (var i = 0; i < buttons.length; i++) if (i !== first - 1) buttons[i].style.backgroundColor = ''
  }
  // function onlyKeepFirst () {
  //   onlykeepfirst()
  //   return send({ from: name, type: 'cleared' })
  // }
  function clearAndNotify () {
    clearSelf()
    return send({ from: name, type: 'not-selecting-second', body: '' })
  }
  function notifyOther () {
    return send({ from: name, type: 'selecting-second' })
  }
  function markRange (btn, A, B) {
    if (A === B) return onlykeepfirst()
    if (A < B) colorRange(A, B)
    else colorRange(B, A)
  }
  function selectSecondOther (btn, current) {
    setStatus('second-selected-by-other')
    return send({ from: name, type: 'value/second', body: second })
  }
  function selectSecond (btn, current) {
    second = current
    setStatus('second-selected-by-self')
    send({ from: name, type: 'second-selected' })
    return send({ from: name, type: 'value/second', body: second })
  }
  function selectFirst (btn, current) {
    clearSelf()
    send({ from: name, type: 'cleared' }) // send notification
    first = current
    btn.style.backgroundColor = 'yellow'
    setStatus('first-selected-by-self')
    return send({ from: name, type: 'value/first', body: first })
  }
  function colorRange (first, second) {
    const btn1 = first - 1
    const btn2 = second - 1
    for (var i = 0; i < buttons.length; i++) {
      if (i < btn1) buttons[i].style.backgroundColor = ''
      if (i === btn1) buttons[i].style.backgroundColor = 'yellow'
      if (i > btn1) buttons[i].style.backgroundColor = 'red'
      if (i === btn2) buttons[i].style.backgroundColor = 'yellow'
      if (i > btn2) buttons[i].style.backgroundColor = ''
    }
  }
  function clearSelf () {
    for (var i = 0; i < buttons.length; i++) buttons[i].style.backgroundColor = ''
    first = second = undefined
  }
  function makeElement (days, next) {
    const cal = document.createElement('div')
    for (var i = 1; i < days + 1; i++) {
      parser.innerHTML = `
        <button num="${i}" style='font-size: 8px; width: 25px; height: 25px;'>
          ${i}
        </button>`
      const [btn] = parser.children
      cal.append(btn)
    }
    return cal
  }
}
// ----------------------------------------------------------------
// make-log.js
// ----------------------------------------------------------------

function makelog (name = '<unknown>') {
  if (!name || global[name]) throw new Error('pick unique name')
  const num = global[name] = Math.floor(Math.random()*360)
  const css1 = style(randomcolor(num), 'white')
  const css2 = style('white', randomcolor(num))
  return function log (message) {
    if (Object(message) !== message) message = { body: message }
    var { from: sender, type = 'log', body } = message
    const relation = type === 'status' ? `--STATUS->` : `==(${type})=>`
    const X = type === 'status' ? `${name}:${sender}` : sender
    var Y = type === 'status' ? body : name
    if (name === sender && type !== 'status') Y = ''
    const value = type === 'status' ? void 0 : body
    console.log(`\n%c${X}%c${relation}%c${Y}`, css1, css2, css1, value)
  }
}
function randomcolor (num) {
  return `hsla(${num},100%,70%,1)`
}
function style (a, b) {
  return `background-color: ${a}; border: 1px solid ${b}; color: black;`
}