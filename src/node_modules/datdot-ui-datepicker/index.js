const debug = require('debug')
const bel = require('bel')
const csjs = require('csjs-inject')
const { format, getMonth, getYear, getDaysInMonth, isBefore, isAfter } = require('date-fns')
const monthResult = require('month-result')
// widgets
const calendarDays = require('../datdot-ui-calendar-days')
const calendarMonth = require('../datdot-ui-calendar-month')
const svg = require('svg')
module.exports = datepicker

function datepicker(protocol) {
    // init
    let ui = 'ui-datepicker'
    const log = debug(ui)
    const sendParent = protocol( receive )
    var send2SubComponent
    sendParent(`from ${ui} say hi`)
    let mode = 'datepicker-range-days' // datepicker-multiple-days, datepicker-range-days, datepicker-repeat
    let data = {
        status: 'cleared',
        type: 'init',
        startDate: {
            from: null,
            date: null
        },
        endDate: {
            from: null,
            date: null
        }
    }
    let daterangepicker = window.sessionStorage
    daterangepicker.setItem('datepicker', JSON.stringify(data))
    let datepicker = JSON.parse(daterangepicker.getItem('datepicker'))
    let status = datepicker.status
    let type = datepicker.type
    let recipients = {}
    let value = {}
    let selectedDates = []
    let startDate, endDate
    // date init
    let date = new Date()
    let year = getYear(date)
    let count = getMonth(date)
    let nextCount = getMonth( new Date(year, count+1) )
    let currentMonth = format( new Date(year, count), 'MMMM')
    let nextMonth = format( new Date(year, count+1), 'MMMM')
    let daysInCurrnetMonth = getDaysInMonth( new Date(year, count))
    let daysInNextMonth = getDaysInMonth( new Date( year, count+1))
    // render calendar
    let cal1 = calendar({name: `${currentMonth} ${year}`, mode, status, type, data: {from: ui, count, month: currentMonth, year, days: daysInCurrnetMonth}}, selectRangeDaysProtocol)
    let cal2 = calendar({name: `${nextMonth} ${year}`, mode, status, type, data: {from: ui, count: nextCount, month: nextMonth, year, days: daysInNextMonth}}, selectRangeDaysProtocol)
    
    // elements
    const iconPrev = svg( { css: `${css.icon} ${css['icon-prev']}`, path: './src/node_modules/assets/arrow-left.svg' } )
    const iconNext = svg( { css: `${css.icon} ${css['icon-next']}`, path: './src/node_modules/assets/arrow-right.svg' } )
    const prevButton  = bel`<button role="button" aria-label="Previous month" class="${css.btn} ${css.prev}" onclick=${()=>triggle(prevButton)}>${iconPrev}</button>`
    const nextButton = bel`<button role="button" aria-label="Next month" class="${css.btn} ${css.next}" onclick=${()=>triggle(nextButton)}>${iconNext}</button>`
    const calendarsDisplay = bel`<div class=${css['datepicker-body']}></div>`
    calendarsDisplay.append(cal1, cal2)
    const el = bel`<section class=${css.datepicker}>${prevButton}${calendarsDisplay}${nextButton}</section>`

    return el

    function calendar({page = 'calendar', name, mode, type, status, selectedDates, selectRangeDates, data}, protocol) {
        const logger = log.extend('calendar')
        // logger(`${name} is ready, calendar status: ${status}`);
        const { from = page, count, month, year, days } = data
        let header = calendarMonth({page: ui, getDate: new Date(year, count), mode}, calendarMonthProtocol)
        let tableDays = bel`<div class=${css['calendar-table-days']}>${calendarDays( {page, name, mode, type, status, style: `${css['calendar-days']}`, data, selectedDates, startDate, endDate}, protocol ) }</div>`
        const weekday = bel`<section class=${css['calendar-weekday']} role="weekday"></section>`
        const weekList= ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']
        weekList.map( w => {
            const div = bel`<div class=${css['calendar-week']} role="week">${w.slice(0 ,1)}</div>`
            weekday.append(div)
        })

        const el = bel`
        <div class=${css.calendar}>
            ${header}
            <div class=${css['calendar-section']}>
            ${weekday}
            ${tableDays}
            </div>
        </div>`

        return el
    }


    function calendarMonthProtocol(message) {
        protocol(message)
    }

    // function calendarProtocol(send) {
    //     send2SubComponent = send
    //     send2SubComponent(`from ${ui} to say hi`)
    //     return (message) => {
    //         if (mode === 'datepicker-multiple-days') return multipleDaysProtocol(message)
    //         if (mode === 'datepicker-range-days') return selectRangeDaysProtocol(message, send)
    //     }
    // }

    function selectRangeDaysProtocol(send) {
        send2SubComponent = send
        send2SubComponent(`from ${ui} to say hi`)
        return message => {
            const { from, type, body } = message
            const logger = log.extend('calendar')
            if (type === 'init') { 
                logger(`${from} ready`)
                return storeSendFN(from, send) 
            }
            if (type === 'value/first') return notifyAndStoreFirst(from, body)
            if (type === 'value/second') return notifyParent(body)
            if (type === 'selecting-second') return notifyOtherCalenderSelectingLast(from)
            if (type === 'cleared') { 
                log('cleared from', from)
                return clearOther(from === currentMonth ? nextMonth : currentMonth) 
            }
            else return forwardMessage(from, message)
        }
        
    }

    function notifyParent (body) {
        value.last = body
        return sendParent({type: 'value', body: value })
    }

    function notifyAndStoreFirst(from, body) {
        value.first = body
        const list = [from]
        const receivers = filterOutRecipients(list)
        const type = from === currentMonth ? 'first-selected-by-startcal' : 'first-selected-by-endcal'
        return broadcast(receivers, { from: name, type })
    }

    function storeSendFN (from, send) {
        recipients[from] = send
      }

    function clearOther (from) {
        const send = recipients[from]
        return send2SubComponent({ from, type: 'clear' }) // send command
    }

    function forwardMessage(from, message) {
        const list = [from]
        const receivers = filterOutRecipients(list)
        broadcast(receivers, message)
    }

    function notifyAndStoreLast (message) {
        const { from, status, type, body, day, count, year } = message
        start = {from: startDate.from, year: startDate.year, count: startDate.count, day: startDate.day, date: startDate.date}
        end = {from, year, count, day, date: body }

        if ( start.year > end.year) {
            return updateSelectDates(status, type, end, start)
        } else {
            if ( start.year === end.year ) {
                if ( start.count > end.count) {
                    return updateSelectDates(status, type, end, start)
                } else {
                    if ( start.day <= end.day ) return updateSelectDates(status, type, start, end)
                    else return updateSelectDates(status, type, end, start)
                }
            } else {
                return updateSelectDates(status, type, start, end)
            }
        }
    }

    function updateSelectDates(status, type, start, end) {
        startDate = start
        endDate = end
        datepicker.status = status
        datepicker.type = type
        datepicker.startDate = { from: start.from, date: start.date }
        datepicker.endDate = end === void 0 ? null : { from: end.from, date: end.date }
        daterangepicker.setItem('datepicker', JSON.stringify(datepicker))
        // log('update startDate', startDate ); // {from: "October 2020", year: 2020, count: 9, day: "20", date: "2020-10-20"}
        // log('daterangepicker', JSON.parse( daterangepicker.getItem('datepicker')) );
    }

    function notifyOtherCalenderSelectingLast (from) {
        if (from === currentMonth) {
            const send = recipients[nextMonth]
            return send({ from: name, type: 'color-from-start' })
        }
        if (from === nextMonth) {
            const send = recipients[currentMonth]
            return send({ from: name, type: 'color-to-end' })
        }
    }
    
    function multipleDaysProtocol(message) {
        const { body } = message
        // if not found date in selectedDates then push body
        if ( selectedDates.indexOf( body ) === -1) selectedDates.push(body)
        else selectedDates.splice(selectedDates.indexOf( body ), 1)
        // change status
        if ( selectedDates.length === 0) setStatus('cleared')
        if ( selectedDates.length > 0) setStatus('selected-dates')
        // console.log(selectedDates);
        return protocol(message)
    }

    function triggle(target) {
        if (target.classList.contains(css.prev)) {
            // decreemnt 2 months
            nextCount = count - 1
            count -= 2
        } else {
            // incremenet 2 months
            count += 2
            nextCount = count+1
        }
        let month1 = monthResult(count)
        let month2 = monthResult(nextCount)
        let updateCal1 = calendarRender({name: `${month1.month} ${month1.year}`, mode, type, ...month1, selectedDates, startDate, endDate})
        let updateCal2 = calendarRender({name: `${month2.month} ${month2.year}`, mode, type, ...month2, selectedDates, startDate, endDate})
        calendarsDisplay.innerHTML = ''
        calendarsDisplay.append(updateCal1, updateCal2)
    }

    function calendarRender({name, mode, type, count, year, month, days, selectedDates, startDate, endDate}) {
        return calendar({page: ui, name, mode, type, status, data: {from: ui, count, month, year, days}, selectedDates, startDate, endDate}, selectRangeDaysProtocol)
    }

    function receive( message ) {
        log(message)
    }

    function notifyParent (body) {
        value.last = body
        return sendParent({ from: name, type: 'value', body: value })
      }

    function filterOutRecipients (list) {
        const receivers = Object.keys(recipients) // get all calendar names
          .filter(name => !list.includes(name)) // only keep name different from message sender
          .map(name => recipients[name]) // for each name, get send function
        return receivers // e.g. receivers = [send2, send4]
      }

    function broadcast (receivers, message) {
        for (var i = 0, len = receivers.length; i < len; i++) {
            const send = receivers[i]
            send(message) // forward message from sender to all receivers send(msg)
        }
    }
}

const css = csjs`
.datepicker {
    display: flex;
}
.datepicker-body {
    display: grid;
    grid-template-rows: auto;
    grid-template-columns: repeat(2, 210px);
    grid-gap: 35px;
}
.calendar {}
.calendarHeader {}
.calendar-weekday {
    display: grid;
    grid-template-rows: auto;
    grid-template-columns: repeat(7, minmax(30px, auto));
    justify-items: center;
}
.calendar-week {}
.calendar-table-days {}
.calendar-days {
    display: grid;
    grid-template-rows: auto;
    grid-template-columns: repeat(7, minmax(30px, auto));
    justify-items: center;
}
.calendar-section {
    font-size: 12px;
}
.btn {
    background: none;
    border: none;
    border-radius: 50px;
    width: 30px;
    height: 30px;
    padding: 0;
    transition: background-color 0.3s ease-in-out;
    cursor: pointer;
}
.btn:active, .btn:hover {
    background-color: #C9C9C9;
}
.btn:active div > svg path, .btn:hover div > svg path {}
.prev {}
.next {}
.icon svg path {
    transition: stroke 0.25s ease-in-out;
}
.icon-prev {}
.icon-next {}
.date-selected-range {
    background-color: #EAEAEA;
}
`